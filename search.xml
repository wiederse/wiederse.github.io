<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023 天梯赛 L2-3 锦标赛</title>
    <url>/2024/02/29/2023%E5%A4%A9%E6%A2%AF%E8%B5%9BL2-3%E9%94%A6%E6%A0%87%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/1649748772841508874?type=7&amp;page=1">L2-047
锦标赛 - 团体程序设计天梯赛-练习集 (pintia.cn)</a></p>
<h2 id="思路">思路</h2>
<p>​
一开始一直想着从最后一轮开始倒序处理，但怎么都无法保证分配的合理性。遍历到前面的轮次可能会不满足。</p>
<p>​ 正确思路如下，先根据第一轮败者完善答案的一半。下标从 <span
class="math inline">\(0\)</span> 开始的话第 <span
class="math inline">\(1\)</span> 轮比赛的第 <span
class="math inline">\(i\)</span> 场败者，可以对应第 <span
class="math inline">\(i\times 2\)</span> 名选手。</p>
<p>​ 第 <span class="math inline">\(i\)</span> 轮比赛的第 <span
class="math inline">\(j\)</span> 场的<strong>败者</strong>其可能与第
<span class="math inline">\(i -1\)</span> 轮比赛的第 <span
class="math inline">\(j \times 2\)</span> 和 <span
class="math inline">\(j\times 2+1\)</span>
的<strong>胜者</strong>比赛。如果其能力值比两者都小的话，没有答案。否则跟任意一个能力值比它小的即可，可以思考一下正确性。</p>
<p>​
为了实现构造还要建立一个数组，记录该败者该放在哪个位置，详细可见代码。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug2(x,y) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; #y &lt;&lt; <span class="string">&quot; = &quot;</span>&lt;&lt; y &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> uLL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">131080</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">l</span>(k), <span class="built_in">nxt</span>(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> n = (<span class="number">1</span> &lt;&lt; (k - i - <span class="number">1</span>));</span><br><span class="line">        l[i].<span class="built_in">resize</span>(n);</span><br><span class="line">        nxt[i].<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; l[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    cin &gt;&gt; w;</span><br><span class="line">    <span class="keyword">if</span>(l[k - <span class="number">1</span>][<span class="number">0</span>] &gt; w) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No Solution\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">1</span> &lt;&lt; k)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>)); i++) &#123;</span><br><span class="line">        ans[i &lt;&lt; <span class="number">1</span>] = l[<span class="number">0</span>][i];</span><br><span class="line">        nxt[<span class="number">0</span>][i] = (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; (k - i - <span class="number">1</span>)); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l[i][j] &lt; l[i - <span class="number">1</span>][j * <span class="number">2</span>] &amp;&amp; l[i][j] &lt; l[i - <span class="number">1</span>][j * <span class="number">2</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No Solution\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> maxl = <span class="built_in">max</span>(&#123;l[i][j], l[i - <span class="number">1</span>][j * <span class="number">2</span>], l[i - <span class="number">1</span>][j * <span class="number">2</span> + <span class="number">1</span>]&#125;);</span><br><span class="line">            <span class="keyword">if</span>(l[i][j] &gt;= l[i - <span class="number">1</span>][j * <span class="number">2</span>]) &#123;</span><br><span class="line">                ans[nxt[i - <span class="number">1</span>][j * <span class="number">2</span>]] = l[i][j];</span><br><span class="line">                nxt[i][j] = nxt[i - <span class="number">1</span>][j * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[nxt[i - <span class="number">1</span>][j * <span class="number">2</span> + <span class="number">1</span>]] = l[i][j];</span><br><span class="line">                nxt[i][j] = nxt[i - <span class="number">1</span>][j * <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            l[i][j] = maxl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug(nxt[k - 1][0]);</span></span><br><span class="line">    ans[nxt[k - <span class="number">1</span>][<span class="number">0</span>]] = w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; k); i++)</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define sunset</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> sunset</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>思维题</category>
      </categories>
  </entry>
  <entry>
    <title>L3-032 关于深度优先搜索和逆序对的题应该不会很难吧这件事</title>
    <url>/2024/03/04/L3-032-%E5%85%B3%E4%BA%8E%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%92%8C%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E9%A2%98%E5%BA%94%E8%AF%A5%E4%B8%8D%E4%BC%9A%E5%BE%88%E9%9A%BE%E5%90%A7%E8%BF%99%E4%BB%B6%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/1518582895035215872?type=7&amp;page=1">L3-032
关于深度优先搜索和逆序对的题应该不会很难吧这件事 -
团体程序设计天梯赛</a></p>
<h2 id="题意">题意</h2>
<p>给定一棵 <span class="math inline">\(n\)</span> 个节点的树，其中节点
<span class="math inline">\(r\)</span> 为根。求该树所有可能的 DFS
序中逆序对数量之和。</p>
<h2 id="思路">思路</h2>
<p>一开始分了两类，第一类为它的所有孩子，第二类为它父亲的除了它及它的孩子的所有孩子。所以少考虑了一些情况，写到最后样例没过才发现问题。第二类应为它的祖先的……</p>
<p>重新进行分类，不妨设它为 <span
class="math inline">\(u\)</span>，第一类为 <span
class="math inline">\(u\)</span> 所有祖先，这一类贡献不会因为 DFS
改变而变。第二类为除了其祖先，子孙和 <span
class="math inline">\(u\)</span> 的所有结点，这一类会改变。</p>
<p>对于第二类结点，不妨设其中一个为 <span
class="math inline">\(v\)</span>，对所有可能的 DFS序，有 <span
class="math inline">\(\frac{1}{2}\)</span> 的概率 <span
class="math inline">\(u\)</span> 在 <span
class="math inline">\(v\)</span> 前面，<span
class="math inline">\(\frac{1}{2}\)</span> 的概率 <span
class="math inline">\(u\)</span> 在 <span
class="math inline">\(v\)</span> 后面。<span
class="math inline">\(u\)</span>
与它的所有第二类结点都可能产生贡献，共计为 <span class="math display">\[
\text{第二类结点数}\times\text{DFS
数量}\times\frac{1}{2}\times\frac{1}{2}
\]</span> 一个 <span class="math inline">\(\frac{1}{2}\)</span>
为位置概率，另一个为一对 <span class="math inline">\((u,v)\)</span>
其贡献会计算两次。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug2(x,y) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; #y &lt;&lt; <span class="string">&quot; = &quot;</span>&lt;&lt; y &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(i) ((i) &amp; (-i))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> uLL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[maxn];</span><br><span class="line"><span class="type">int</span> c[maxn], n, dep[maxn], son[maxn], fac[maxn];</span><br><span class="line">LL base = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL b, LL p, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    b %= k;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, b = b * b % k)</span><br><span class="line">        <span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans = ans * b % k;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; x &lt;= n; x += <span class="built_in">lowbit</span>(x)) c[x] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; x; x -= <span class="built_in">lowbit</span>(x)) res += c[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    ans = (ans + dep[u] - <span class="number">1</span> - <span class="built_in">sum</span>(u)) % mod;</span><br><span class="line">    <span class="built_in">add</span>(u, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : e[u])</span><br><span class="line">        <span class="keyword">if</span>(v != fa) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            son[u] += son[v] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt) base = base * fac[cnt] % mod;</span><br><span class="line">    <span class="built_in">add</span>(u, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; r;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        fac[i] = (LL)fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(r, <span class="number">0</span>);</span><br><span class="line">    ans = ans * base % mod;</span><br><span class="line">    <span class="type">int</span> inv2 = <span class="built_in">qpow</span>(<span class="number">2</span>, mod - <span class="number">2</span>, mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = (ans + (n - dep[i] - son[i]) * base % mod * inv2 % mod * inv2 % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define sunset</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> sunset</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>思维题</category>
      </categories>
  </entry>
  <entry>
    <title>F-命运的抉择_2024牛客寒假算法基础集训营6</title>
    <url>/2024/02/25/F-%E5%91%BD%E8%BF%90%E7%9A%84%E6%8A%89%E6%8B%A9-2024%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A56/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://ac.nowcoder.com/acm/contest/67746/F">F-命运的抉择_2024牛客寒假算法基础集训营6
(nowcoder.com)</a></p>
<h2 id="题意">题意</h2>
<p>给一个长度为 <span class="math inline">\(n(2\le n\le 10^5)\)</span>
的数组 <span class="math inline">\(a(1\le a_i\le 10^6)\)</span>，对每个
<span class="math inline">\(a_i\)</span> 将其添加进数组 <span
class="math inline">\(b\)</span> 或数组 <span
class="math inline">\(c\)</span>​。要求 <span
class="math inline">\(b\)</span> 和 <span
class="math inline">\(c\)</span> 均非空，两个数组中各任取一个元素 <span
class="math inline">\(b_i,c_j\)</span>，均满足 <span
class="math inline">\(\gcd(b_i,c_j)=1\)</span>。</p>
<h2 id="思路">思路</h2>
<p>先用筛法预处理出 <span class="math inline">\(10^6\)</span>
范围内每个数的素因子。</p>
<p>然后采用并查集，如果两个数包含同一个素因子，那么它们就必须在同一个集合内。最终如果集合数小于
<span
class="math inline">\(2\)</span>，则无解。对于可行解，可以将一个集合放入数组
<span class="math inline">\(b\)</span>，其余集合放入数组 <span
class="math inline">\(c\)</span>。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug2(x,y) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; #y &lt;&lt; <span class="string">&quot; = &quot;</span>&lt;&lt; y &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> uLL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxa = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn], f[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; fac[<span class="number">1&#x27;000&#x27;001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        f[i] = i;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : fac[a[i]]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(x) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                f[<span class="built_in">find</span>(i)] = <span class="built_in">find</span>(mp[x]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> mp[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fir = <span class="number">0</span>, sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> f = <span class="built_in">find</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(!vis[f]) &#123;</span><br><span class="line">            vis[f] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(fir == <span class="number">0</span>) fir = f;</span><br><span class="line">            <span class="keyword">else</span> sec = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!sec) cout &lt;&lt; <span class="string">&quot;-1 -1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> lb = <span class="number">0</span>, lc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i) == fir) lb++;</span><br><span class="line">            <span class="keyword">else</span> lc++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; lb &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; lc &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i) == fir) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i) != fir) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define sunset</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> sunset</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxa; i++) <span class="keyword">if</span>(fac[i].<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= maxa; j += i) fac[j].<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>数论</category>
        <category>数据结构</category>
        <category>筛法</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>筛法</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>一些数论算法及证明</title>
    <url>/2024/01/25/%E4%B8%80%E4%BA%9B%E6%95%B0%E8%AE%BA%E7%AE%97%E6%B3%95%E5%8F%8A%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h2 id="辗转相除法">辗转相除法</h2>
<p><strong>等式 1</strong> 如果 <span class="math inline">\(a\mid
b\)</span> 且 <span class="math inline">\(b\mid a\)</span>，那么 <span
class="math inline">\(a=b\)</span></p>
<p><strong>等式 2</strong> 如果 <span class="math inline">\(d\mid
a\)</span> 且 <span class="math inline">\(d\mid b\)</span> 那么 <span
class="math inline">\(d\mid(ax + by);x,y \in Z\)</span></p>
<p><strong>等式 3</strong> <span class="math inline">\(a\bmod\ n = a -
n\left \lfloor\frac{a}{n}\right \rfloor;a\in Z,n\in N^{*}\)</span></p>
<p><strong>推论 1</strong> 对任意整数 <span
class="math inline">\(a\)</span>, <span
class="math inline">\(b\)</span>，如果 <span class="math inline">\(d\mid
a\)</span> 且 <span class="math inline">\(d\mid b\)</span> 则 <span
class="math inline">\(d\mid\gcd(a, b)\)</span></p>
<p>如果我们想要获得结论 <span class="math inline">\(\gcd(a,b) =
\gcd(b,a\bmod\ b)\)</span></p>
<p>那么我们只需要证明 <span
class="math inline">\(\gcd(a,b)\mid\gcd(b,a\bmod b)\)</span> 且 <span
class="math inline">\(\gcd(b,a\bmod b)\mid\gcd(a,b)\)</span>
就可以来证明它俩相等了。</p>
<h3 id="证明-gcdabmidgcdbabmod-b">证明 <span
class="math inline">\(\gcd(a,b)\mid\gcd(b,a\bmod b)\)</span></h3>
<blockquote>
<p>设 <span class="math inline">\(d = \gcd(a, b)\)</span> <span
class="math inline">\(\therefore d\mid a\)</span> 且 <span
class="math inline">\(d\mid b\)</span>。<br />
由 <strong>等式 3</strong> 可知：<span class="math inline">\(a\pmod b =
a - qb,q = \left \lfloor\frac{a}{b}\right \rfloor\)</span><br />
<span class="math inline">\(\therefore a\bmod\ b\)</span> 是 a 与 b
的<strong>线性组合</strong><br />
由 <strong>等式 2</strong> 可知：<span class="math inline">\(d\mid
a\pmod b\)</span><br />
<span class="math inline">\(\because d\mid b\)</span> 且 <span
class="math inline">\(d\mid a\pmod b\)</span><br />
<span class="math inline">\(\therefore\)</span> 由 <strong>推论
1</strong> 可知 <span class="math inline">\(d\mid\gcd(b, a\bmod\
b)\)</span><br />
<strong>等价结论：</strong> <span class="math inline">\(\gcd(a,
b)\mid\gcd(b, a\bmod\ b)\)</span></p>
</blockquote>
<h3 id="证明-gcdbabmod-bmidgcdab">证明 <span
class="math inline">\(\gcd(b,a\bmod\ b)\mid\gcd(a,b)\)</span></h3>
<blockquote>
<p>设 <span class="math inline">\(c = \gcd(b, a\bmod\ b)\)</span><br />
<span class="math inline">\(\therefore c\mid b\)</span> 且 <span
class="math inline">\(c\mid a\pmod b\)</span><br />
<span class="math inline">\(\because a = qb + r,r = a\bmod\ b,q = \left
\lfloor\frac{a}{b}\right \rfloor\)</span><br />
<span class="math inline">\(\therefore a\)</span> 是 <span
class="math inline">\(b\)</span> 和 <span class="math inline">\(a\bmod\
b\)</span> 的<strong>线性组合</strong><br />
由 <strong>等式 2</strong> 可知：<span class="math inline">\(c\mid
a\)</span><br />
<span class="math inline">\(\because c\mid a\)</span> 且 <span
class="math inline">\(c\mid b\)</span><br />
由 <strong>推论 1</strong> 可知：<span
class="math inline">\(c\mid\gcd(a, b)\)</span><br />
<strong>等价结论：</strong> <span class="math inline">\(\gcd(b, a\bmod\
b)\mid\gcd(a, b)\)</span></p>
</blockquote>
<h3 id="证明-gcdab-gcdb-abmod-b">证明 <span
class="math inline">\(\gcd(a,b) = \gcd(b, a\bmod b)\)</span></h3>
<blockquote>
<p>由 上述两个结论 可知： <span class="math display">\[
\begin{aligned}
\gcd(a, b)\mid\gcd(b, a\bmod\ b)\\
\gcd(b, a\bmod\ b)\mid\gcd(a, b)
\end{aligned}
\]</span> 由 <strong>等式 1</strong> 可知：<span
class="math inline">\(\gcd(a, b) = \gcd(b, a\bmod\ b)\)</span></p>
</blockquote>
<h2 id="扩展欧几里得算法">扩展欧几里得算法</h2>
<p>求 <span class="math inline">\(ax+by=gcd(a,b)\)</span></p>
<p>设</p>
<p><span class="math display">\[
\begin{aligned}
ax_1+by_1&amp;=\gcd(a,b) \\
bx_2+(a\bmod b)y_2&amp;=\gcd(b,a\bmod b)
\end{aligned}
\]</span></p>
<p>由欧几里得定理可知：<span
class="math inline">\(\gcd(a,b)=\gcd(b,a\bmod b)\)</span></p>
<p>所以 <span class="math inline">\(ax_1+by_1=bx_2+(a\bmod
b)y_2\)</span></p>
<p>又因为 <span class="math inline">\(a\bmod
b=a-\lfloor\frac{a}{b}\rfloor\times b\)</span></p>
<p>所以 <span class="math display">\[
ax_1+by_1=bx_2+(a-\lfloor\frac{a}{b}\rfloor\times b)y_2
\]</span> <span
class="math inline">\(ax_1+by_1=ay_2+bx_2-\lfloor\frac{a}{b}\rfloor\times
by_2=ay_2+b(x_2-\lfloor\frac{a}{b}\rfloor y_2)\)</span></p>
<p><span class="math inline">\(a,b\)</span> 相同，所以 <span
class="math inline">\(x_1=y_2,y_1=x_2-\lfloor\frac{a}{b}\rfloor
y_2\)</span></p>
<p>将 <span class="math inline">\(x_2,y_2\)</span> 不断代入递归求解直至
<span class="math inline">\(\gcd\)</span>（最大公约数，下同）为 0 递归
<code>x=1,y=0</code> 回去求解。</p>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">  <span class="type">int</span> t = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = t - (a / b) * y;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="同余方程">同余方程</h2>
<p>求关于 <span class="math inline">\(x\)</span> 的同余方程 <span
class="math inline">\(a x \equiv 1 \pmod b\)</span> 的最小正整数解。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，<span
class="math inline">\(2\le a, b\le 2,000,000,000\)</span>。</p>
<h3 id="solution">solution</h3>
<p><span class="math inline">\(ax\bmod\ b=1\)</span> 实质是 <span
class="math inline">\(ax+by=1\)</span>。 <span
class="math inline">\(y\)</span>
是我们引入的某个整数，这里似乎是个负数。</p>
<p>扩展欧几里得求 <span
class="math inline">\(ax+by=\gcd(a,b)\)</span>，所以这里 <span
class="math inline">\(\gcd(a,b)=1\)</span>，即 <span
class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>
互质。所以 <span class="math inline">\(a\)</span> 有模 <span
class="math inline">\(b\)</span> 下的乘法逆元的条件为 <span
class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>
互质。</p>
<p>我们将要求出来的 <span class="math inline">\(x\)</span>， <span
class="math inline">\(y\)</span> 仅仅保证满足 <span
class="math inline">\(ax+by=1\)</span>，而 <span
class="math inline">\(x\)</span>
不一定是最小正整数解。有可能太大，也有可能是负数。<span
class="math inline">\(x\)</span> 批量的减去或加上 <span
class="math inline">\(b\)</span>，能保证 <span
class="math inline">\(ax+by=1\)</span>。因为： <span
class="math display">\[
a(x+kb)+b(y-ka)=1
\]</span> 这里我们可以这么写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = (x % b + b) % b</span><br></pre></td></tr></table></figure>
<h2 id="二元一次不定方程">二元一次不定方程</h2>
<p><a href="https://www.luogu.com.cn/problem/P5656">P5656
【模板】二元一次不定方程 (exgcd) - 洛谷 | 计算机科学教育新生态
(luogu.com.cn)</a></p>
<p><span class="math display">\[
ax+by=c
\]</span></p>
<p><span class="math inline">\(\gcd(a,b)\mid(ax+by)\)</span>，若 <span
class="math inline">\(c\)</span> 不是 <span
class="math inline">\(\gcd(a,b)\)</span> 的倍数直接无解</p>
<p>记 <span class="math inline">\(ax+by=\gcd(a,b)\)</span> 的一组特解为
<span class="math inline">\(x_0\)</span>，<span
class="math inline">\(y_0\)</span>。则有:</p>
<p><span class="math display">\[
\begin{aligned}
ax_0+by_0=\gcd(a,b) \\
a\frac{x_0c}{\gcd(a,b)}+b\frac{y_0c}{\gcd(a,b)}=c
\end{aligned}
\]</span></p>
<p>故我们已经找到原方程的一组整数特解，记为 <span
class="math inline">\(x_1\)</span> 和 <span
class="math inline">\(y_1\)</span></p>
<p><span class="math display">\[
\begin{aligned}
x_1=\frac{x_0c}{\gcd(a,b)}, \quad y_1=\frac{y_0c}{\gcd(a,b)}
\end{aligned}
\]</span></p>
<p>那么我们考虑构造原方程整数通解形式</p>
<p>我们设任意 <span class="math inline">\(d\in Q\)</span>，那么必有
<span class="math display">\[
a(x_1+db)+b(y_1-da)=c
\]</span> 显然对于最小的 <span class="math inline">\(db\)</span>，<span
class="math inline">\(da\)</span>，<span
class="math inline">\(d=\frac{1}{\gcd(a,b)}\)</span></p>
<p>然后像上面一样开始乱搞</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> d = <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line"><span class="keyword">if</span>(c % d) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = c * x / d, y = c * y / d;</span><br><span class="line"><span class="type">int</span> dx = b / d, dy = a / d;</span><br><span class="line"><span class="type">int</span> minx = (x % dx + dx) % dx;</span><br><span class="line"><span class="keyword">if</span>(minx == <span class="number">0</span>) minx = dx;</span><br><span class="line"><span class="type">int</span> maxy = (c - a * minx) / b;</span><br><span class="line"><span class="type">int</span> miny = (y % dy + dy) % dy;</span><br><span class="line"><span class="keyword">if</span>(miny == <span class="number">0</span>) miny = dy;</span><br><span class="line"><span class="type">int</span> maxx = (c - b * miny) / a;</span><br></pre></td></tr></table></figure>
<h2 id="中国剩余定理">中国剩余定理</h2>
<h3 id="模数不互质的情况">模数不互质的情况</h3>
<p>设两个方程分别是 <span class="math inline">\(x\equiv a_1\pmod
m_1,x\equiv a_2\pmod m_2\)</span></p>
<p>将它们转化为不定方程：<span
class="math inline">\(x=m_1p+a_1=m_2q+a_2\)</span>，其中 <span
class="math inline">\(p, q\)</span> 是整数，则有 <span
class="math inline">\(m_1p-m_2q=a_2-a_1\)</span>。</p>
<p>由裴属定理，当 <span class="math inline">\(a_2-a_1\)</span> 不能被
<span class="math inline">\(\gcd(m_1,m_2)\)</span> 整除时，无解；</p>
<p>其他情况下，可以通过扩展欧几里得算法解出来一组可行解 <span
class="math inline">\((p,q)\)</span>；</p>
<p>则原来的两方程组的模方程组的解为 <span class="math inline">\(x\equiv
b\pmod M\)</span>，其中 <span class="math inline">\(b=m_1p+a_1\)</span>,
<span class="math inline">\(M=\mathrm{lcm}(m_1,m_2)\)</span>。</p>
<h2 id="lucas-定理">Lucas 定理</h2>
<p>对于质数 <span class="math inline">\(p\)</span>，有</p>
<p><span class="math display">\[
\binom{n}{m}\bmod
p=\binom{\lfloor\frac{n}{p}\rfloor}{\lfloor\frac{m}{p}\rfloor}\cdot\binom{n\bmod
p}{m\bmod p}\bmod p
\]</span></p>
<p>观察上述表达式，可知 <span class="math inline">\(n\bmod p\)</span> 和
<span class="math inline">\(m\bmod p\)</span> 一定是小于 <span
class="math inline">\(p\)</span> 的数，可以直接求解，<span
class="math inline">\(\displaystyle\binom{\left\lfloor\frac{n}{p}\right\rfloor}{\left\lfloor\frac{m}{p}\right\rfloor}\)</span>
可以继续用 Lucas 定理求解。这也就要求 <span
class="math inline">\(p\)</span> 的范围不能够太大，一般在 <span
class="math inline">\(10^5\)</span> 左右。边界条件：当 <span
class="math inline">\(m=0\)</span> 的时候，返回 <span
class="math inline">\(1\)</span>。</p>
<h3 id="证明">证明</h3>
<p>考虑 <span class="math inline">\(\displaystyle\binom{p}{n} \bmod
p\)</span> 的取值，注意到 <span
class="math inline">\(\displaystyle\binom{p}{n} =
\frac{p!}{n!(p-n)!}\)</span>，分子的质因子分解中 <span
class="math inline">\(p\)</span> 的次数恰好为 <span
class="math inline">\(1\)</span>，因此只有当 <span
class="math inline">\(n = 0\)</span> 或 <span class="math inline">\(n =
p\)</span> 的时候 <span class="math inline">\(n!(p-n)!\)</span>
的质因子分解中含有 <span class="math inline">\(p\)</span>，因此 <span
class="math inline">\(\displaystyle\binom{p}{n} \bmod p = [n = 0 \vee n
= p]\)</span>。进而我们可以得出:</p>
<p><span class="math display">\[
\begin{align} (a+b)^p &amp;= \sum_{n=0}^p \binom pn a^n b^{p-n}\\
&amp;\equiv \sum_{n=0}^p [n=0\vee n=p] a^n b^{p-n}\\ &amp;\equiv a^p +
b^p \pmod p \end{align}
\]</span></p>
<p>注意过程中没有用到费马小定理，因此这一推导不仅适用于整数，亦适用于多项式。因此我们可以考虑二项式
<span class="math inline">\(f^p(x)=(ax^n + bx^m)^p \bmod p\)</span>
的结果</p>
<p><span class="math display">\[
\begin{align} (ax^n + bx^m)^p &amp;\equiv a^p x^{pn} + b^p x^{pm} \\
&amp;\equiv ax^{pn} + bx^{pm}\\ &amp;\equiv f(x^p) \end{align}
\]</span></p>
<blockquote>
<p>note: <span class="math inline">\(a^{p-1}\equiv
1\pmod{p}\)</span></p>
</blockquote>
<p>考虑二项式 <span class="math inline">\((1+x)^n \bmod p\)</span>，那么
<span class="math inline">\(\displaystyle\binom n m\)</span> 就是求其在
<span class="math inline">\(x^m\)</span>
次项的取值。使用上述引理，我们可以得到</p>
<p><span class="math display">\[
\begin{align} (1+x)^n &amp;\equiv (1+x)^{p\lfloor n/p \rfloor}
(1+x)^{n\bmod p}\\ &amp;\equiv (1+x^p)^{\lfloor n/p \rfloor}
(1+x)^{n\bmod p} \end{align}
\]</span></p>
<p>注意前者只有在 <span class="math inline">\(p\)</span>
的倍数位置才有取值，而后者最高次项为 <span class="math inline">\(n\bmod
p \le
p-1\)</span>，因此这两部分的卷积在任何一个位置只有最多一种方式贡献取值，即在前者部分取
<span class="math inline">\(p\)</span>
的倍数次项，后者部分取剩余项，即</p>
<p><span class="math display">\[
\displaystyle\binom{n}{m}\bmod p = \binom{\left\lfloor n/p
\right\rfloor}{\left\lfloor m/p\right\rfloor}\cdot\binom{n\bmod
p}{m\bmod p}\bmod p
\]</span></p>
<h2 id="扩展-lucas定理">扩展 Lucas定理</h2>
<p>求</p>
<p><span class="math display">\[
{\mathrm{C}}_n^m \bmod{p}
\]</span></p>
<p>其中 <span class="math inline">\(p\le
10^6\)</span>，<strong>不保证</strong> <span
class="math inline">\(p\)</span> 为质数。</p>
<h3 id="证明-1">证明</h3>
<p><a
href="https://www.luogu.com.cn/blog/wohaocaia/solution-p4720">扩展Lucas定理
- HorizonWind 的洛谷博客</a></p>
<h2 id="莫比乌斯反演">莫比乌斯反演</h2>
<p>若 <span class="math inline">\(f\)</span> 是算数函数，<span
class="math inline">\(F\)</span> 为 <span
class="math inline">\(f\)</span> 的和函数，对任意正整数 <span
class="math inline">\(n\)</span>，满足 <span
class="math inline">\(F(n)=\sum_{d\mid n}f(d)\)</span>，则有 <span
class="math inline">\(f(n)=\sum_{d\mid
n}\mu(d)F(\frac{n}{d})\)</span></p>
<p>证明：</p>
<p><span class="math inline">\(i\mid\frac{n}{d}\iff id\mid n\iff d\mid
\frac{n}{i}\)</span></p>
<p><span class="math display">\[
\begin{align}
\sum_{d\mid n}\mu(d)F(\frac{n}{d})&amp;=\sum_{d\mid
n}\mu(d)\sum_{i\mid\frac{n}{d}}f(i) \\
&amp;=\sum_{i\mid n}f(i)\sum_{d\mid\frac{n}{i}}\mu(d)
\end{align}
\]</span></p>
<p>当 <span class="math inline">\(\frac{n}{i}\)</span> 为 <span
class="math inline">\(1\)</span> 的时候，<span
class="math inline">\(\sum_{d\mid\frac{n}{i}}\mu(d)=1\)</span>，其它均为
<span class="math inline">\(0\)</span>。</p>
<p>所以</p>
<p><span class="math display">\[
\sum_{d\mid n}\mu(d)F(\frac{n}{d})=f(n)
\]</span></p>
<hr />
<p>若 <span class="math inline">\(F(n)=\sum_{n\mid d}f(d)\)</span>，则
<span class="math inline">\(f(n)=\sum_{n\mid
d}\mu(\frac{d}{n})F(d)\)</span></p>
<p>证明： <span class="math display">\[
\sum_{n\mid d}\mu(\frac{d}{n})F(d)=\sum_{n\mid
d}\mu(\frac{d}{n})\sum_{d\mid i}f(i)
\]</span> <span class="math inline">\(n\mid d\)</span>，设 <span
class="math inline">\(d&#39;=\frac{d}{n}\)</span>，<span
class="math inline">\(d=d&#39;n\)</span></p>
<p><span class="math inline">\(d\mid i\)</span>，则 <span
class="math inline">\(d&#39;n\mid i\)</span>，即 <span
class="math inline">\(d&#39;\mid \frac{i}{n}\)</span> <span
class="math display">\[
\sum_{n\mid d}\mu(\frac{d}{n})\sum_{d\mid i}f(i)=\sum_{n\mid
i}f(i)\sum_{d&#39;\mid\frac{i}{n}}\mu(d&#39;)
\]</span> 当 <span class="math inline">\(\frac{i}{n}\)</span> 为 <span
class="math inline">\(1\)</span>，即 <span
class="math inline">\(i=n\)</span> 时，<span
class="math inline">\(\sum_{d&#39;\mid\frac{i}{n}}\mu(d&#39;)=1\)</span>，其余均为
<span class="math inline">\(0\)</span></p>
<p>所以</p>
<p><span class="math display">\[
\sum_{n\mid d}\mu(\frac{d}{n})F(d)=f(n)
\]</span></p>
<h3 id="反演结论">反演结论</h3>
<p><span class="math display">\[
d(ij)=\sum_{x\mid i}\sum_{y\mid j}[\gcd(x,y)=1]
\]</span></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>根号分治学习笔记</title>
    <url>/2024/03/17/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="cf103d-time-to-raid-cowavans"><a
href="https://codeforces.com/contest/103/problem/D">CF103D Time to Raid
Cowavans</a></h1>
<h2 id="题意">题意</h2>
<p>给一个序列 <span class="math inline">\(a\)</span>，<span
class="math inline">\(m\)</span> 次询问，每次询问给出 <span
class="math inline">\(t,k\)</span>。求 <span
class="math inline">\(a_t+a_{t+k}+a_{t+2k}+\dots+a_{t+pk}\)</span>
的值，其中 <span class="math inline">\(t+pk&lt;=n\)</span> 且 <span
class="math inline">\(t+(p+1)k&gt; n\)</span></p>
<p><span class="math inline">\(n,m\le 300000,a_i\le 10^9\)</span></p>
<h2 id="思路">思路</h2>
<p>如果对每个间隔 <span class="math inline">\(k\)</span>
预处理前缀和的话，因为 <span class="math inline">\(1\le k\le
n\)</span>，所以时间复杂度为 <span
class="math inline">\(O(n^2)\)</span>。但进一步想，对于比较大的间隔，暴力其实已经很快了。每次暴力扫描所有位置的时间复杂度是
<span class="math inline">\(O(\frac{n}{k})\)</span></p>
<p>当 <span class="math inline">\(k\ge\sqrt{n}\)</span> 时，<span
class="math inline">\(\frac{n}{k}\le\sqrt{n}\)</span>，每次询问时间复杂度为
<span class="math inline">\(O(\sqrt{n})\)</span> 所以总的时间复杂度为
<span class="math inline">\(n\sqrt{n}\)</span>。</p>
<p>当 <span class="math inline">\(k&lt;\sqrt{n}\)</span> 时，<span
class="math inline">\(O(n)\)</span> 预处理前缀和，每次 <span
class="math inline">\(O(1)\)</span> 查询，所以总的时间复杂度为 <span
class="math inline">\(O(n\sqrt{n})\)</span>​。</p>
<p>另外这个题空间给的比较少，需要离线处理。</p>
<h2 id="代码">代码</h2>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug2(x,y) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; #y &lt;&lt; <span class="string">&quot; = &quot;</span>&lt;&lt; y &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> uLL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S = <span class="number">547</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;LL&gt; <span class="title">pre</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 3&gt; &gt; <span class="built_in">ques</span>(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;[l, b, id] = ques[i];</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; b;</span><br><span class="line">        id = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ques.<span class="built_in">begin</span>(), ques.<span class="built_in">end</span>(), [&amp;](array&lt;<span class="type">int</span>, <span class="number">3</span>&gt; x, array&lt;<span class="type">int</span>, <span class="number">3</span>&gt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">1</span>] &lt; y[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function">vector&lt;LL&gt; <span class="title">ans</span><span class="params">(q + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [l, b, id] = ques[i];</span><br><span class="line">        <span class="keyword">if</span>(b &gt; S) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = l; j &lt;= n; j += b) &#123;</span><br><span class="line">                ans[id] += a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!i || b != ques[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                pre[j] = pre[<span class="built_in">max</span>(<span class="number">0</span>, j - b)] + a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[id] = pre[(n - l) / b * b + l] - pre[<span class="built_in">max</span>(<span class="number">0</span>, l - b)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define sunset</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> sunset</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h1 id="flippingbitsdiv1---topcoder-12728"><a
href="https://vjudge.net/problem/TopCoder-12728">FlippingBitsDiv1 -
TopCoder 12728</a></h1>
<h2 id="题意-1">题意</h2>
<p>给一个长度为 <span class="math inline">\(N(N&lt;300)\)</span> 的
<span class="math inline">\(01\)</span> 字符串，再给一个正整数 <span
class="math inline">\(M\)</span>。每次操作，你可以将一个位置取反，或者将一个长度为
<span class="math inline">\(M\)</span>
的倍数的前缀取反。问最少需要多少次操作，才能使字符串成为一个循环节为
<span class="math inline">\(M\)</span> 的循环串。</p>
<p>循环节长度为 <span class="math inline">\(M\)</span> 定义为，对于任意
<span class="math inline">\(i\)</span>，如果 <span
class="math inline">\(i+M\)</span> 这个位置存在，那么 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(i+M\)</span>​​ 上的字符应该相等。</p>
<h2 id="思路-1">思路</h2>
<p>循环节的长度和循环节的个数相互制约，总有一个不超过 <span
class="math inline">\(\sqrt{n}\)</span>。</p>
<p>对于 <span
class="math inline">\(m\le\sqrt{n}\)</span>，循环节的长度不超过 <span
class="math inline">\(\sqrt{300}\approx
17\)</span>，并不长。我们直接枚举最后的循环节，时间复杂度为 <span
class="math inline">\(2^{17}\)</span>。然后每一段必须和答案相等或者相反即可，这里可以通过动态规划。设
<span class="math inline">\(dp[i][0/1]\)</span>，第一维为这是第 <span
class="math inline">\(i\)</span> 段，第二位 <span
class="math inline">\(0/1\)</span>
为这一段是否反转，那么可以得到如下转移方程。 <span
class="math display">\[
\begin{align}
dp[i][0] &amp;= min(dp[i - 1][0], dp[i - 1][1]) + notEqu \\
dp[i][1] &amp;= min(dp[i - 1][0] + equ + 2, dp[i - 1][1] + equ)
\end{align}
\]</span> 其中 <span class="math inline">\(equ\)</span>
为这一段与循环串相同的个数，<span class="math inline">\(notEqu\)</span>
即为不同的个数。</p>
<p>对于 <span
class="math inline">\(m&gt;\sqrt{n}\)</span>，循环节的个数不是很多，我们枚举每一段是否反转，对于答案串的每一位，如果所有循环节在这一位的
<span class="math inline">\(0\)</span> 比较多，就是 <span
class="math inline">\(0\)</span>。否则就是 <span
class="math inline">\(1\)</span>。</p>
<p>所以总的时间复杂度为 <span class="math inline">\(O(n\times
2^{\sqrt{n}})\)</span></p>
<h2 id="代码-1">代码</h2>
<p>TopCoder 交不明白，此代码没有经过测试。</p>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug2(x,y) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; #y &lt;&lt; <span class="string">&quot; = &quot;</span>&lt;&lt; y &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> uLL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> pivot = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FlippingBitsDiv1</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getmin</span><span class="params">(vector&lt;string&gt; S, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        string s&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : S) &#123;</span><br><span class="line">            s += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// debug(s);</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>(), cnt = (n - <span class="number">1</span>) / m + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">ss</span><span class="params">(cnt)</span></span>;</span><br><span class="line">        <span class="comment">// debug(cnt);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; i * m + j &lt; n &amp;&amp; j &lt; m; j++) &#123;</span><br><span class="line">                ss[i] += s[i * m + j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(m &lt;= pivot) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++) &#123;</span><br><span class="line">                string t&#123;&#125;;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                    t += <span class="built_in">char</span>(((i &gt;&gt; j) &amp; <span class="number">1</span>) + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// debug(t);</span></span><br><span class="line">                vector&lt;array&lt;<span class="type">int</span>, 2&gt; &gt; <span class="built_in">dp</span>(cnt);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> equ = <span class="number">0</span>, not_equ = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; ss[i].<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(ss[i][j] == t[j]) equ++;</span><br><span class="line">                        <span class="keyword">else</span> not_equ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// debug2(i, ss[i]);</span></span><br><span class="line">                    <span class="comment">// debug2(equ, not_equ);</span></span><br><span class="line">                    <span class="keyword">if</span>(!i) &#123;</span><br><span class="line">                        dp[i][<span class="number">0</span>] = not_equ;</span><br><span class="line">                        dp[i][<span class="number">1</span>] = equ + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) + not_equ;</span><br><span class="line">                        dp[i][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] + equ + <span class="number">2</span>, dp[i - <span class="number">1</span>][<span class="number">1</span>] + equ);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">min</span>(&#123;ans, dp[cnt - <span class="number">1</span>][<span class="number">0</span>], dp[cnt - <span class="number">1</span>][<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; cnt); i++) &#123;</span><br><span class="line">                vector&lt;<span class="type">bool</span>&gt; <span class="built_in">re</span>(cnt);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = cnt - <span class="number">1</span>; ~j; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == cnt - <span class="number">1</span>) re[j] = (i &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> re[j] = re[j + <span class="number">1</span>] ^ ((i &gt;&gt; j) &amp; <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; sum[<span class="number">2</span>];</span><br><span class="line">                sum[<span class="number">0</span>].<span class="built_in">resize</span>(m);</span><br><span class="line">                sum[<span class="number">1</span>].<span class="built_in">resize</span>(m);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; ss[i].<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">                        sum[(ss[i][j] - <span class="string">&#x27;0&#x27;</span>) ^ re[i]][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                    tot += <span class="built_in">min</span>(sum[<span class="number">0</span>][i], sum[<span class="number">1</span>][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, tot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; FBD1;</span><br></pre></td></tr></table></figure>

</details>
<h1 id="ioi2009-regions"><a
href="https://www.luogu.com.cn/problem/P5901">IOI2009 Regions</a></h1>
<h2 id="题意-2">题意</h2>
<p><span class="math inline">\(N\)</span> 个节点的树，<span
class="math inline">\(R\)</span> 种属性。每个点属于一种属性。有 <span
class="math inline">\(Q\)</span> 次询问，每次询问 <span
class="math inline">\((r_1,r_2)\)</span>，问有多少对 <span
class="math inline">\((e_1,e_2)\)</span> 满足 <span
class="math inline">\(e_1\)</span> 的属性是 <span
class="math inline">\(r_1\)</span>, <span
class="math inline">\(e_2\)</span> 属性是 <span
class="math inline">\(r_2\)</span>, <span
class="math inline">\(e_1\)</span> 是 <span
class="math inline">\(e_2\)</span> 的祖先。</p>
<p><span class="math inline">\(1\le N,Q\le 2\times 10^5,\quad 1\le R\le
2.5\times 10^4\)</span></p>
<h2 id="思路-2">思路</h2>
<p>不妨设询问中 <span class="math inline">\(r_1\)</span>
属性的点的个数为 <span class="math inline">\(A,\ r_2\)</span> 属性的点有
<span class="math inline">\(B\)</span> 个。</p>
<p>属性的点的个数超过 <span class="math inline">\(\sqrt{n}\)</span>
的属性不超过 <span class="math inline">\(\sqrt{n}\)</span>
个，我们先求出这棵树的 dfs 序。</p>
<p>对于 <span class="math inline">\(A\ge\sqrt{n}\)</span>
的情况，我们可以以 <span class="math inline">\(O(n)\)</span>
的时间复杂度预处理 <span class="math inline">\(r_1\)</span> 对所有 <span
class="math inline">\(r2\)</span> 的答案。所以总的时间复杂度为 <span
class="math inline">\(O(n\sqrt{n})\)</span>。 维护一个差分数组 <span
class="math inline">\(d\)</span>，对于所有属性为 <span
class="math inline">\(r_1\)</span> 的点，设其入栈时间为 <span
class="math inline">\(x\)</span>，最后一个孩子入栈时间为 <span
class="math inline">\(y\)</span>。让
<code>d[x]++, d[y + 1]--</code>，然后求 <span
class="math inline">\(d\)</span>
的前缀和。那么对于所有其它属性，其祖先为 <span
class="math inline">\(r_1\)</span> 的对数为 <code>d[x]</code>。</p>
<p>对于 <span class="math inline">\(B\ge\sqrt{n}\)</span>，同理我们让
<code>d[x]++</code>，求 <span class="math inline">\(d\)</span>
的前缀和，那么对于所有其它属性，其孩子为 <span
class="math inline">\(r_2\)</span> 的对数为
<code>d[y] - d[x - 1]</code>。时间复杂度也是 <span
class="math inline">\(O(n\sqrt{n})\)</span></p>
<p>对于 <span class="math inline">\(A,B\le\sqrt{n}\)</span>
的情况，我们采用扫描线的方法，相当于求多少线段过这个点。一次询问为 <span
class="math inline">\(O(n)\)</span>，有 <span
class="math inline">\(Q\)</span> 组询问，时间复杂度为 <span
class="math inline">\(O(Q\sqrt{n})\)</span>，<span
class="math inline">\(Q\)</span> 于 <span
class="math inline">\(n\)</span> 同一个量级。</p>
<p>所以总的时间复杂度为 <span
class="math inline">\(O(n\sqrt{n})\)</span></p>
<h2 id="代码-2">代码</h2>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="comment">// #define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug2(x,y) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; #y &lt;&lt; <span class="string">&quot; = &quot;</span>&lt;&lt; y &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> uLL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxr = <span class="number">25e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> pivot = <span class="number">447</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[maxn], hid[maxr];</span><br><span class="line">vector&lt;pii&gt; seg[maxr];</span><br><span class="line"><span class="type">int</span> h[maxn], dfn, ans1[<span class="number">450</span>][maxr], ans2[<span class="number">450</span>][maxr], d[maxn], num[maxn];</span><br><span class="line">pii lr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    lr[u].first = ++dfn;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    lr[u].second = dfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, r, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; r &gt;&gt; q &gt;&gt; h[<span class="number">1</span>];</span><br><span class="line">    hid[h[<span class="number">1</span>]].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> fa;</span><br><span class="line">        cin &gt;&gt; fa &gt;&gt; h[i];</span><br><span class="line">        e[fa].<span class="built_in">push_back</span>(i);</span><br><span class="line">        hid[h[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hid[i].<span class="built_in">size</span>() &gt;= pivot) &#123;</span><br><span class="line">            num[i] = ++cnt;</span><br><span class="line">            <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> id : hid[i]) &#123;</span><br><span class="line">                d[lr[id].first]++;</span><br><span class="line">                d[lr[id].second + <span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++)</span><br><span class="line">                d[j] += d[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">if</span>(h[j] != i) &#123;</span><br><span class="line">                    ans1[cnt][h[j]] += d[lr[j].first];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> id : hid[i]) &#123;</span><br><span class="line">                d[lr[id].first]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++)</span><br><span class="line">                d[j] += d[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">if</span>(h[j] != i) &#123;</span><br><span class="line">                    ans2[cnt][h[j]] += d[lr[j].second] - d[lr[j].first - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">sort</span>(hid[i].<span class="built_in">begin</span>(), hid[i].<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">                <span class="keyword">return</span> lr[a].first &lt; lr[b].first;</span><br><span class="line">            &#125;); <span class="comment">//</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> id : hid[i]) &#123;</span><br><span class="line">                seg[i].<span class="built_in">push_back</span>(&#123;lr[id].first, <span class="number">1</span>&#125;);</span><br><span class="line">                seg[i].<span class="built_in">push_back</span>(&#123;lr[id].second + <span class="number">1</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(seg[i].<span class="built_in">begin</span>(), seg[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> r1, r2;</span><br><span class="line">        cin &gt;&gt; r1 &gt;&gt; r2;</span><br><span class="line">        <span class="keyword">if</span>(hid[r1].<span class="built_in">size</span>() &gt;= pivot) &#123;</span><br><span class="line">            cout &lt;&lt; ans1[num[r1]][r2] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(hid[r2].<span class="built_in">size</span>() &gt;= pivot) &#123;</span><br><span class="line">            cout &lt;&lt; ans2[num[r2]][r1] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> tot = <span class="number">0</span>, ans = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> id : hid[r2]) &#123;</span><br><span class="line">                <span class="keyword">while</span>(now &lt; seg[r1].<span class="built_in">size</span>() &amp;&amp; seg[r1][now].first &lt;= lr[id].first) &#123;</span><br><span class="line">                    tot += seg[r1][now].second;</span><br><span class="line">                    now++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += tot;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define sunset</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> sunset</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h1 id="cf101e-candies-and-stones"><a
href="https://www.luogu.com.cn/problem/CF101E">CF101E Candies and
Stones</a></h1>
<h2 id="思路-3">思路</h2>
<p>递推式很明显： <span class="math display">\[
dp[i][j] = max\{dp[i-1][j],dp[i][j-1]\}+(x[i]+y[i])\bmod n
\]</span> <span class="math inline">\(n\)</span> 为 <span
class="math inline">\(20000\)</span>，<span
class="math inline">\(O(n^2)\)</span> 显然可行，但注意到空间只有 <span
class="math inline">\(45MB\)</span>，而用 <span
class="math inline">\(bitset\)</span> 记录转移信息需要 <span
class="math inline">\(20000*20000/8/1024/1024=47.68MB\)</span>。</p>
<p>我们可以对 <span class="math inline">\(dp[i][j]\)</span>
的第一维进行分块，块长为 <span
class="math inline">\(B\)</span>。先跑一遍的 <span
class="math inline">\(dp\)</span>，处理出每个块首的 <span
class="math inline">\(dp\)</span>
信息和最后的结果。然后倒序处理每个块。对每个块正着跑一遍记录转移信息，倒着跑一遍输出具体方案。</p>
<p>空间上，开大小为 <span class="math inline">\(\frac{n}{B}\times
B\)</span> 的数组记录每个块块首的状态，开 <span
class="math inline">\(\frac{Bn}{w}\)</span>
的数组记录每个块内的转移信息。平衡一下，解的 <span
class="math inline">\(B=\sqrt{nw}\)</span>​。</p>
<p><span class="math inline">\(\text{P.S.}\)</span> 其实 <span
class="math inline">\(47.68\)</span> 与 <span
class="math inline">\(45\)</span> 比差距不大，只分成两块就可以通过</p>
<h2 id="代码-3">代码</h2>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug2(x,y) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; #y &lt;&lt; <span class="string">&quot; = &quot;</span>&lt;&lt; y &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> uLL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> pivot = <span class="number">800</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[maxn], y[maxn], dp_block[<span class="number">26</span>][maxn], dp[maxn];</span><br><span class="line">bitset&lt;maxn&gt; f[<span class="number">801</span>], b[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define sunset</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> sunset</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n, m, p;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="type">bool</span> choose_x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &gt;= dp[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                choose_x = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] += (x[i] + y[j]) % p;</span><br><span class="line">            <span class="keyword">if</span>(i % pivot == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> id = (i - <span class="number">1</span>) / pivot + <span class="number">1</span>;</span><br><span class="line">                dp_block[id][j] = dp[j];</span><br><span class="line">                b[id][j] = choose_x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">    stack&lt;<span class="type">bool</span>, vector&lt;<span class="type">bool</span>&gt; &gt; s;</span><br><span class="line">    <span class="type">int</span> nowx = n, nowy = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = (n - <span class="number">1</span>) / pivot + <span class="number">1</span>; i; i--) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(dp, dp_block[i], <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        f[<span class="number">1</span>] = b[i];</span><br><span class="line">        <span class="type">int</span> st = (i - <span class="number">1</span>) * pivot;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= pivot &amp;&amp; st + j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[k] &gt;= dp[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                    f[j][k] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[j][k] = <span class="number">0</span>;</span><br><span class="line">                    dp[k] = dp[k - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                dp[k] += (x[st + j] + y[k]) % p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nowx &gt; st &amp;&amp; nowx &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[nowx - st][nowy]) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">                nowx--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">                nowy--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(nowy &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">        nowy--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; ((s.<span class="built_in">top</span>() == <span class="number">1</span>) ? <span class="string">&#x27;C&#x27;</span> : <span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>数据结构</category>
        <category>分块</category>
      </categories>
      <tags>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title>花又落</title>
    <url>/2026/02/09/%E8%8A%B1%E5%8F%88%E8%90%BD/</url>
    <content><![CDATA[<p>异乡求学，寒暑更替，时隔半年终于再次回到了达活泉公园。上次来还是暑假，这次走到南门西侧，我不禁在想：天这么冷，那群“合唱团”的爷爷奶奶们还在吗？</p>
<p>还没走到跟前，长廊内溢出的歌声就打消了我的顾虑。与去年露天的景象不同，不知是否是为了御寒，长廊入口挂起了厚门帘，内部也被隔断围成了一间温馨的小屋，镂空的窗棂更是细心地用塑料布封得严严实实——想必是他们自己动的手。</p>
<p>“合唱团”壮大了不少，但伴奏依旧是那位拉二胡的爷爷，那是团里唯一的乐器。驻足倾听，《军人本色》、《花又落》、《小白杨》，和去年听到的顺序一模一样。尤其是《花又落》，正是因为去年听了他们的合唱，我才特意加进了自己的歌单，我一直觉得他们这首的合唱比原唱动听。</p>
<p>我站在门口，年轻的面孔显得有些格格不入。他们停下来看着我，眼神里带着疑惑，似乎在想这是谁家的孙子。我冲他们笑了笑，像久别重逢的老友。</p>
<p>每次回家，我都要来这里看一看。这群充满活力的老人，仿佛成了我与故乡之间某种隐秘的纽带，那股热气腾腾的生命力，总能激励着我继续前行。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>花束枯萎之后</title>
    <url>/2026/02/15/%E8%8A%B1%E6%9D%9F%E6%9E%AF%E8%90%8E%E4%B9%8B%E5%90%8E/</url>
    <content><![CDATA[<p>《献给阿尔吉侬的花束》是一位学姐推荐的一本书，碰巧另一位学姐也在看。</p>
<p>书中的主人公查理生来就有智力障碍，自然也遭受着原生家庭的摧残——充满执念的母亲，看似理性的父亲，即是受害者又是加害者的妹妹。他从小渴望着“便匆名”，以为只要变聪明就能重获父母的爱。</p>
<p>后来他通过手术变得聪明了，甚至超过了正常人，但智慧离间了他和所有爱他的人，他发现朋友们并不是喜欢他，只是在愚弄他，取笑他。原来被他视作救世主的实验室教授/医生，只把他当作可以扬名立万的实验成果，不认为他在实验前就已经是个人了。他从面包店被赶出来，跟阿尔吉侬一起逃亡。</p>
<blockquote>
<p>不过不久前，我才知道别人都在嘲笑我。现在我知道自己已在不知不觉间加入他们，嘲笑起自己。这点才是最让我难过的。</p>
</blockquote>
<p>这几个月来，他的智力虽然不断增长，但心智并没有成熟，仍旧保持着查理幼稚的情感框架，无法与过去的自己和解。这期间又新增了许多痛苦与挣扎……</p>
<p>他逐渐感觉到自己对艾丽斯·纪尼安小姐的情感变得丰富而复杂。纪尼安是多么温柔善良的人啊，爱上纪尼安小姐简直是人之常情。不管是在智力障碍时还是变聪明后纪尼安小姐都一直陪伴着他，担心他会收到伤害。但书中的纪尼安和费伊的形象过于扁平，成为塑造主人公，推动剧情发展的工具人。作为短篇幅的第一人称小说，一定程度上可以理解。但是书中的有些男女关系的剧情我实在不敢恭维。</p>
<p>他发现了另一个让他震惊和害怕的事实——阿尔吉侬的智力开始急剧倒退，这印证了让他恐惧的猜测——实验结果不是永久性的，他的智力也将步阿尔吉侬的后尘，在到达巅峰之后迅速退化。他从教授们手中接过了这个以自己为对象的实验，证明了实验的缺陷。最后在他给尼姆教授信里，他平静地说：“我还是很高兴能为人类心灵的运作与人工增长智能的控制法则知识，带来一点小小的贡献。”</p>
<p>阿尔吉侬在愤怒和消沉中死去了，查理把它埋在后花园里，开始了孤单而艰难的自我发现之旅。他原谅了原生家庭对自己的伤害，与纪安尼小姐享受了短暂而珍贵的时光，在面包店重新收获了友谊。逐渐他退回到了最初的智力水平，忘记了发生在他身上的所有奇迹。他不要纪尼安小姐、面包店里的每个人为他难过，他要永远离开这里去一个有很多像他一样的人地方。</p>
<p>我始终觉得科幻小说是现实的一面镜子，只是稍微扭曲了一下。不管是软科幻还是硬科幻，都应是对人类现实的反映。这也是为什么我不会对《三体》给出那么高的评价，因为我认为它在载道方面还欠点火候。但《献给阿尔吉侬的花束》却让我深思如何与原生家庭和解，如何与过去的自己，与他人，与这个世界和解，如何坦然接受命运的无常。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>《莫失莫忘》随笔</title>
    <url>/2026/01/29/%E3%80%8A%E8%8E%AB%E5%A4%B1%E8%8E%AB%E5%BF%98%E3%80%8B%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p>石黑一雄虽从小在英国长大，但这篇作品，尤其后三章真相的揭露，字里行间流露着日本的“物哀”美学，一种无法言说的悲伤，无可慰藉的苦痛。小说中的人物只能在既定框架下面对早已注定的命运，没有反抗，甚至连逃避都没有，不免让人“恼火”。可事实上现实不也如此，在社会这个大浪潮下，你又能改变些什么呢？有时我在想，上帝宏观不掷骰子，微观掷骰子。你的努力只是微观层面上的扰动，改变不了整体宏观层面上早已注定的命运，甚至连你的努力都是确定性的。这么一想不免悲从中来，但正因如此，我拼了命也要改变些什么，留下些什么……</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
