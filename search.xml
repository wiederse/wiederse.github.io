<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>F-命运的抉择_2024牛客寒假算法基础集训营6</title>
    <url>/2024/02/25/F-%E5%91%BD%E8%BF%90%E7%9A%84%E6%8A%89%E6%8B%A9-2024%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A56/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://ac.nowcoder.com/acm/contest/67746/F">F-命运的抉择_2024牛客寒假算法基础集训营6
(nowcoder.com)</a></p>
<h2 id="题意">题意</h2>
<p>给一个长度为 <span class="math inline">\(n(2\le n\le 10^5)\)</span>
的数组 <span class="math inline">\(a(1\le a_i\le 10^6)\)</span>，对每个
<span class="math inline">\(a_i\)</span> 将其添加进数组 <span
class="math inline">\(b\)</span> 或数组 <span
class="math inline">\(c\)</span>​。要求 <span
class="math inline">\(b\)</span> 和 <span
class="math inline">\(c\)</span> 均非空，两个数组中各任取一个元素 <span
class="math inline">\(b_i,c_j\)</span>，均满足 <span
class="math inline">\(gcd(b_i,c_j)=1\)</span>。</p>
<h2 id="思路">思路</h2>
<p>先用筛法预处理出 <span class="math inline">\(10^6\)</span>
范围内每个数的素因子。</p>
<p>然后采用并查集，如果两个数包含同一个素因子，那么它们就必须在同一个集合内。最终如果集合数小于
<span
class="math inline">\(2\)</span>，则无解。对于可行解，可以将一个集合放入数组
<span class="math inline">\(b\)</span>，其余集合放入数组 <span
class="math inline">\(c\)</span>。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug2(x,y) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; #y &lt;&lt; <span class="string">&quot; = &quot;</span>&lt;&lt; y &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> uLL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxa = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn], f[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; fac[<span class="number">1&#x27;000&#x27;001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        f[i] = i;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : fac[a[i]]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(x) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                f[<span class="built_in">find</span>(i)] = <span class="built_in">find</span>(mp[x]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> mp[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fir = <span class="number">0</span>, sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> f = <span class="built_in">find</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(!vis[f]) &#123;</span><br><span class="line">            vis[f] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(fir == <span class="number">0</span>) fir = f;</span><br><span class="line">            <span class="keyword">else</span> sec = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!sec) cout &lt;&lt; <span class="string">&quot;-1 -1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> lb = <span class="number">0</span>, lc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i) == fir) lb++;</span><br><span class="line">            <span class="keyword">else</span> lc++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; lb &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; lc &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i) == fir) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i) != fir) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define sunset</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> sunset</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxa; i++) <span class="keyword">if</span>(fac[i].<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= maxa; j += i) fac[j].<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>数论</category>
        <category>筛法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>筛法</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>一些数论算法及证明</title>
    <url>/2024/01/25/%E4%B8%80%E4%BA%9B%E6%95%B0%E8%AE%BA%E7%AE%97%E6%B3%95%E5%8F%8A%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h2 id="辗转相除法">辗转相除法</h2>
<p><strong>等式 1</strong> 如果 <span class="math inline">\(a |
b\)</span> 且 <span class="math inline">\(b|a\)</span>，那么 <span
class="math inline">\(a\pm b\)</span></p>
<p><strong>等式 2</strong> 如果 <span class="math inline">\(d|a\)</span>
且 <span class="math inline">\(d|b\)</span> 那么 <span
class="math inline">\(d|(ax + by)\ x,y \in Z\)</span></p>
<p><strong>等式 3</strong> <span class="math inline">\(a\bmod\ n = a -
n⌊\frac{a}{n}⌋\)</span>; a∈Z,n∈N*(正整数)</p>
<p><strong>推论 1</strong> 对任意整数 <span
class="math inline">\(a\)</span> , <span
class="math inline">\(b\)</span>，如果 <span
class="math inline">\(d|a\)</span> 且 <span
class="math inline">\(d|b\)</span> 则 <span
class="math inline">\(d|gcd(a, b)\)</span></p>
<p>如果我们想要获得结论 <span class="math inline">\(gcd(a,\ b) = gcd(b,\
a\bmod\ b)\)</span></p>
<p>那么我们只需要证明 <span class="math inline">\(gcd(a,b)|gcd(b, a\bmod
b)\)</span> 且 <span class="math inline">\(gcd(b,a\bmod
b)|gcd(a,b)\)</span> 就可以来证明它俩相等了。</p>
<h3 id="证明-gcdabgcdbabmod-b">证明 <span
class="math inline">\(gcd(a,b)|gcd(b,a\bmod b)\)</span></h3>
<blockquote>
<p>设 <span class="math inline">\(d = gcd(a, b)\)</span> <span
class="math inline">\(∴ d|a 且 d|b\)</span> 由 <strong>等式 3</strong>
可知：<span class="math inline">\((a\bmod\ b) = a - qb\quad q =
⌊a/b⌋\)</span> <span class="math inline">\(∴ a\bmod\ b\)</span> 是 a 与
b 的<strong>线性组合</strong> 由 <strong>等式 2</strong> 可知 ：<span
class="math inline">\(d|(a\bmod\ b)\)</span> ∵ <span
class="math inline">\(d|b\)</span> 且 <span
class="math inline">\(d|(a\bmod\ b)\)</span> ∴ 由 <strong>推论
1</strong> 可知 <span class="math inline">\(d|gcd(b, a\bmod\ b)\)</span>
<strong>等价结论：</strong> <span class="math inline">\(gcd(a, b)|gcd(b,
a\bmod\ b)\)</span></p>
</blockquote>
<h3 id="证明-gcdbabmod-bgcdab">证明 <span
class="math inline">\(gcd(b,a\bmod\ b)|gcd(a,b)\)</span></h3>
<blockquote>
<p>设 <span class="math inline">\(c = gcd(b, a\bmod\ b)\)</span> ∴ <span
class="math inline">\(c|b 且 c|(a\bmod\ b)\)</span> ∵ <span
class="math inline">\(a = qb + r\)</span> <span class="math inline">\(r
= a\bmod\ b\)</span> <span class="math inline">\(q =
⌊\frac{a}{b}⌋\)</span> ∴ <span class="math inline">\(a\)</span> 是 <span
class="math inline">\(b\)</span> 和 <span class="math inline">\((a\bmod\
b)\)</span> 的<strong>线性组合</strong> ∴ 由 <strong>等式 2</strong>
可知：<span class="math inline">\(c|a\)</span> ∵ <span
class="math inline">\(c|a\)</span> 且 <span
class="math inline">\(c|b\)</span> ∴ 由 <strong>推论 1</strong>
可知：<span class="math inline">\(c|gcd(a, b)\)</span>
<strong>等价结论：</strong> <span class="math inline">\(gcd(b, a\bmod\
b)|gcd(a, b)\)</span></p>
</blockquote>
<h3 id="证明-gcdab-gcdb-abmod-b">证明 <span
class="math inline">\(gcd(a,b) = gcd(b, a\bmod b)\)</span></h3>
<blockquote>
<p>由 上述两个结论 可知： <span class="math inline">\(gcd(a, b)|gcd(b,
a\bmod\ b)\)</span> <span class="math inline">\(gcd(b, a\bmod\ b)|gcd(a,
b)\)</span> ∴ 由 <strong>等式 1</strong> 可知： <span
class="math inline">\(gcd(a, b) = gcd(b, a\bmod\ b)\)</span></p>
</blockquote>
<h2 id="扩展欧几里得算法">扩展欧几里得算法</h2>
<ul>
<li>求 <span class="math inline">\(ax+by=gcd(a,b)\)</span></li>
</ul>
<p>设</p>
<p><span class="math inline">\(ax_1+by_1=\gcd(a,b)\)</span></p>
<p><span class="math inline">\(bx_2+(a\bmod b)y_2=\gcd(b,a\bmod
b)\)</span></p>
<p>由欧几里得定理可知：<span
class="math inline">\(\gcd(a,b)=\gcd(b,a\bmod b)\)</span></p>
<p>所以 <span class="math inline">\(ax_1+by_1=bx_2+(a\bmod
b)y_2\)</span></p>
<p>又因为 <span class="math inline">\(a\bmod
b=a-\lfloor\frac{a}{b}\rfloor\times b\)</span></p>
<p>所以 <span class="math display">\[
ax_1+by_1=bx_2+(a-\lfloor\frac{a}{b}\rfloor\times b)y_2
\]</span> <span
class="math inline">\(ax_1+by_1=ay_2+bx_2-\lfloor\frac{a}{b}\rfloor\times
by_2=ay_2+b(x_2-\lfloor\frac{a}{b}\rfloor y_2)\)</span></p>
<p><span class="math inline">\(a,b\)</span> 相同，所以 <span
class="math inline">\(x_1=y_2,y_1=x_2-\lfloor\frac{a}{b}\rfloor
y_2\)</span></p>
<p>将 <span class="math inline">\(x_2,y_2\)</span> 不断代入递归求解直至
<span class="math inline">\(\gcd\)</span>（最大公约数，下同）为
<code>0</code> 递归 <code>x=1,y=0</code> 回去求解。</p>
<details class="note info no-icon"><summary><p>code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">  <span class="type">int</span> t = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = t - (a / b) * y;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="同余方程">同余方程</h2>
<p>求关于 $ x$ 的同余方程 $ a x $ 的最小正整数解。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，<span
class="math inline">\(2 ≤a, b≤ 2,000,000,000\)</span>。</p>
<h3 id="solution">solution</h3>
<p><span class="math inline">\(ax\bmod\ b=1\)</span> 实质是 <span
class="math inline">\(ax+by=1\)</span>。 <span
class="math inline">\(y\)</span>
是我们引入的某个整数，这里似乎是个负数。</p>
<p>扩展欧几里得求 <span
class="math inline">\(ax+by=gcd(a,b)\)</span>，所以这里 <span
class="math inline">\(gcd(a,b)=1\)</span>，即 <span
class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>
互质。所以 <span class="math inline">\(a\)</span> 有模 <span
class="math inline">\(b\)</span> 下的乘法逆元的条件为 <span
class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>
互质。</p>
<p>我们将要求出来的 <span class="math inline">\(x\)</span>， <span
class="math inline">\(y\)</span> 仅仅保证满足 <span
class="math inline">\(ax+by=1\)</span>，而 <span
class="math inline">\(x\)</span>
不一定是最小正整数解。有可能太大，也有可能是负数。<span
class="math inline">\(x\)</span> 批量的减去或加上 <span
class="math inline">\(b\)</span>，能保证 <span
class="math inline">\(ax+by=1\)</span>。因为： <span
class="math display">\[
a(x+kb)+b(y-ka)=1
\]</span> 这里我们可以这么写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = (x % b + b) % b</span><br></pre></td></tr></table></figure>
<h2 id="二元一次不定方程">二元一次不定方程</h2>
<p><a href="https://www.luogu.com.cn/problem/P5656">P5656
【模板】二元一次不定方程 (exgcd) - 洛谷 | 计算机科学教育新生态
(luogu.com.cn)</a> <span class="math display">\[
ax+by=c
\]</span> <span class="math inline">\(gcd(a,b)|(ax+by)\)</span>，若
<span class="math inline">\(c\)</span> 不是 <span
class="math inline">\(gcd(a,b)\)</span> 的倍数直接无解</p>
<p>记 <span class="math inline">\(ax+by=gcd(a,b)\)</span> 的一组特解为
<span class="math inline">\(x_0\)</span>，<span
class="math inline">\(y_0\)</span>。则有 <span class="math display">\[
ax_0+by_0=gcd(a,b) \\
a\frac{x_0c}{gcd(a,b)}+b\frac{y_0c}{gcd(a,b)}=c
\]</span> 故我们已经找到原方程的一组整数特解，记为 <span
class="math inline">\(x_1\)</span> 和 <span
class="math inline">\(y_1\)</span> <span class="math display">\[
x_1=\frac{x_0c}{gcd(a,b)}\quad y_1=\frac{y_0c}{gcd(a,b)}
\]</span> 那么我们考虑构造原方程整数通解形式</p>
<p>我们设任意 <span class="math inline">\(d\in Q\)</span>，那么必有
<span class="math display">\[
a(x_1+db)+b(y_1-da)=c
\]</span> 显然对于最小的 <span class="math inline">\(db\)</span>，<span
class="math inline">\(da\)</span>，<span
class="math inline">\(d=\frac{1}{gcd(a,b)}\)</span></p>
<p>然后像上面一样开始乱搞</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> d = <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line"><span class="keyword">if</span>(c % d) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = c * x / d, y = c * y / d;</span><br><span class="line"><span class="type">int</span> dx = b / d, dy = a / d;</span><br><span class="line"><span class="type">int</span> minx = (x % dx + dx) % dx;</span><br><span class="line"><span class="keyword">if</span>(minx == <span class="number">0</span>) minx = dx;</span><br><span class="line"><span class="type">int</span> maxy = (c - a * minx) / b;</span><br><span class="line"><span class="type">int</span> miny = (y % dy + dy) % dy;</span><br><span class="line"><span class="keyword">if</span>(miny == <span class="number">0</span>) miny = dy;</span><br><span class="line"><span class="type">int</span> maxx = (c - b * miny) / a;</span><br></pre></td></tr></table></figure>
<h2 id="中国剩余定理">中国剩余定理</h2>
<h3 id="模数不互质的情况">模数不互质的情况</h3>
<p>设两个方程分别是 <span class="math inline">\(x\equiv a_1\ (mod\
m_1)\)</span>、<span class="math inline">\(x\equiv a_2\ (mod\
m_2)\)</span>；</p>
<p>将它们转化为不定方程：<span
class="math inline">\(x=m_1p+a_1=m_2q+a_2\)</span>，其中 <span
class="math inline">\(p, q\)</span> 是整数，则有 <span
class="math inline">\(m_1p-m_2q=a_2-a_1\)</span>。</p>
<p>由裴属定理，当 <span class="math inline">\(a_2-a_1\)</span> 不能被
<span class="math inline">\(gcd(m_1,m_2)\)</span> 整除时，无解；</p>
<p>其他情况下，可以通过扩展欧几里得算法解出来一组可行解 <span
class="math inline">\((p,q)\)</span>；</p>
<p>则原来的两方程组的模方程组的解为 <span class="math inline">\(x\equiv
b\ (mod\ M)\)</span>，其中 <span
class="math inline">\(b=m_1p+a_1\)</span>, <span
class="math inline">\(M=lcm(m_1,m_2)\)</span>。</p>
<h2 id="lucas-定理">Lucas 定理</h2>
<p>对于质数 <span class="math inline">\(p\)</span>，有 <span
class="math display">\[
\binom{n}{m}\bmod
p=\binom{\lfloor\frac{n}{p}\rfloor}{\lfloor\frac{m}{p}\rfloor}\cdot\binom{n\bmod
p}{m\bmod p}\bmod p
\]</span> 观察上述表达式，可知 <span class="math inline">\(n\bmod
p\)</span> 和 <span class="math inline">\(m\bmod p\)</span> 一定是小于
<span class="math inline">\(p\)</span>的数，可以直接求解，<span
class="math inline">\(\displaystyle\binom{\left\lfloor\frac{n}{p}\right\rfloor}{\left\lfloor\frac{m}{p}\right\rfloor}\)</span>
可以继续用 Lucas 定理求解。这也就要求 <span
class="math inline">\(p\)</span> 的范围不能够太大，一般在 <span
class="math inline">\(10^5\)</span> 左右。边界条件：当 <span
class="math inline">\(m=0\)</span> 的时候，返回 <span
class="math inline">\(1\)</span>。</p>
<h3 id="证明">证明</h3>
<p>考虑 <span class="math inline">\(\displaystyle\binom{p}{n} \bmod
p\)</span> 的取值，注意到 <span
class="math inline">\(\displaystyle\binom{p}{n} =
\frac{p!}{n!(p-n)!}\)</span>，分子的质因子分解中 <span
class="math inline">\(p\)</span> 的次数恰好为 <span
class="math inline">\(1\)</span>，因此只有当 <span
class="math inline">\(n = 0\)</span> 或 <span class="math inline">\(n =
p\)</span> 的时候 <span class="math inline">\(n!(p-n)!\)</span>
的质因子分解中含有 <span class="math inline">\(p\)</span>，因此 <span
class="math inline">\(\displaystyle\binom{p}{n} \bmod p = [n = 0 \vee n
= p]\)</span>。进而我们可以得出</p>
<p><span class="math display">\[
\begin{align} (a+b)^p &amp;= \sum_{n=0}^p \binom pn a^n b^{p-n}\\
&amp;\equiv \sum_{n=0}^p [n=0\vee n=p] a^n b^{p-n}\\ &amp;\equiv a^p +
b^p \pmod p \end{align}
\]</span>
注意过程中没有用到费马小定理，因此这一推导不仅适用于整数，亦适用于多项式。因此我们可以考虑二项式
<span class="math inline">\(f^p(x)=(ax^n + bx^m)^p \bmod p\)</span>
的结果</p>
<p><span class="math display">\[
\begin{align} (ax^n + bx^m)^p &amp;\equiv a^p x^{pn} + b^p x^{pm} \\
&amp;\equiv ax^{pn} + bx^{pm}\\ &amp;\equiv f(x^p) \end{align}
\]</span></p>
<blockquote>
<p>note: <span class="math inline">\(a^{(p-1)}\equiv
1\pmod{p}\)</span></p>
</blockquote>
<p>考虑二项式 <span class="math inline">\((1+x)^n \bmod p\)</span>，那么
<span class="math inline">\(\displaystyle\binom n m\)</span> 就是求其在
<span class="math inline">\(x^m\)</span>
次项的取值。使用上述引理，我们可以得到 <span class="math display">\[
\begin{align} (1+x)^n &amp;\equiv (1+x)^{p\lfloor n/p \rfloor}
(1+x)^{n\bmod p}\\ &amp;\equiv (1+x^p)^{\lfloor n/p \rfloor}
(1+x)^{n\bmod p} \end{align}
\]</span></p>
<p>注意前者只有在 <span class="math inline">\(p\)</span>
的倍数位置才有取值，而后者最高次项为 <span class="math inline">\(n\bmod
p \le
p-1\)</span>，因此这两部分的卷积在任何一个位置只有最多一种方式贡献取值，即在前者部分取
<span class="math inline">\(p\)</span> 的倍数次项，后者部分取剩余项，即
<span class="math inline">\(\displaystyle\binom{n}{m}\bmod p =
\binom{\left\lfloor n/p \right\rfloor}{\left\lfloor
m/p\right\rfloor}\cdot\binom{n\bmod p}{m\bmod p}\bmod p\)</span>。</p>
<h2 id="扩展-lucas定理">扩展 Lucas定理</h2>
<p><a
href="https://www.luogu.com.cn/blog/wohaocaia/solution-p4720">扩展Lucas定理
- HorizonWind 的博客 - 洛谷博客 (luogu.com.cn)</a></p>
<h2 id="莫比乌斯反演">莫比乌斯反演</h2>
<p>若 <span class="math inline">\(f\)</span> 是算数函数，<span
class="math inline">\(F\)</span> 为 <span
class="math inline">\(f\)</span> 的和函数，对任意正整数 <span
class="math inline">\(n\)</span>，满足 <span
class="math inline">\(F(n)=\sum_{d\mid n}f(d)\)</span>，则有 <span
class="math inline">\(f(n)=\sum_{d\mid
n}\mu(d)F(\frac{n}{d})\)</span></p>
<p>证明：</p>
<p><span class="math inline">\(i\mid\frac{n}{d}\iff id\mid n\iff d\mid
\frac{n}{i}\)</span> <span class="math display">\[
\begin{align}
\sum_{d\mid n}\mu(d)F(\frac{n}{d})&amp;=\sum_{d\mid
n}\mu(d)\sum_{i\mid\frac{n}{d}}f(i) \\
&amp;=\sum_{i\mid n}f(i)\sum_{d\mid\frac{n}{i}}\mu(d)
\end{align}
\]</span></p>
<p>当 <span class="math inline">\(\frac{n}{i}\)</span> 为 <span
class="math inline">\(1\)</span> 的时候，<span
class="math inline">\(\sum_{d\mid\frac{n}{i}}\mu(d)=1\)</span>，其它均为
<span class="math inline">\(0\)</span>。</p>
<p>所以</p>
<p><span class="math display">\[
\sum_{d\mid n}\mu(d)F(\frac{n}{d})=f(n)
\]</span></p>
<hr />
<p>若 <span class="math inline">\(F(n)=\sum_{n\mid d}f(d)\)</span>，则
<span class="math inline">\(f(n)=\sum_{n\mid
d}\mu(\frac{d}{n})F(d)\)</span></p>
<p>证明： <span class="math display">\[
\sum_{n\mid d}\mu(\frac{d}{n})F(d)=\sum_{n\mid
d}\mu(\frac{d}{n})\sum_{d\mid i}f(i)
\]</span> <span class="math inline">\(n\mid d\)</span>，设 <span
class="math inline">\(d&#39;=\frac{d}{n}\)</span>，<span
class="math inline">\(d=d&#39;n\)</span></p>
<p><span class="math inline">\(d\mid i\)</span>，则 <span
class="math inline">\(d&#39;n\mid i\)</span>，即 <span
class="math inline">\(d&#39;\mid \frac{i}{n}\)</span> <span
class="math display">\[
\sum_{n\mid d}\mu(\frac{d}{n})\sum_{d\mid i}f(i)=\sum_{n\mid
i}f(i)\sum_{d&#39;\mid\frac{i}{n}}\mu(d&#39;)
\]</span> 当 <span class="math inline">\(\frac{i}{n}\)</span> 为 <span
class="math inline">\(1\)</span>，即 <span
class="math inline">\(i=n\)</span> 时，<span
class="math inline">\(\sum_{d&#39;\mid\frac{i}{n}}\mu(d&#39;)=1\)</span>，其余均为
<span class="math inline">\(0\)</span></p>
<p>所以</p>
<p><span class="math display">\[
\sum_{n\mid d}\mu(\frac{d}{n})F(d)=f(n)
\]</span></p>
<h3 id="反演结论">反演结论</h3>
<p><span class="math display">\[
d(ij)=\sum_{x\mid i}\sum_{y\mid j}[\gcd(x,y)=1]
\]</span></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>数论</category>
      </categories>
  </entry>
</search>
